// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/verbovyar/OzonCart/internal/repositories/interfaces.RepositoryIface -o repository_iface_mock.go -n RepositoryIfaceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/verbovyar/OzonCart/internal/repositories/db/postgres"
)

// RepositoryIfaceMock implements mm_interfaces.RepositoryIface
type RepositoryIfaceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(ctx context.Context, userID uint64, skuID uint64, count uint64) (err error)
	funcAddItemOrigin    string
	inspectFuncAddItem   func(ctx context.Context, userID uint64, skuID uint64, count uint64)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mRepositoryIfaceMockAddItem

	funcClearCart          func(ctx context.Context, userID uint64) (err error)
	funcClearCartOrigin    string
	inspectFuncClearCart   func(ctx context.Context, userID uint64)
	afterClearCartCounter  uint64
	beforeClearCartCounter uint64
	ClearCartMock          mRepositoryIfaceMockClearCart

	funcDeleteItem          func(ctx context.Context, userID uint64, skuID uint64) (err error)
	funcDeleteItemOrigin    string
	inspectFuncDeleteItem   func(ctx context.Context, userID uint64, skuID uint64)
	afterDeleteItemCounter  uint64
	beforeDeleteItemCounter uint64
	DeleteItemMock          mRepositoryIfaceMockDeleteItem

	funcGetCart          func(ctx context.Context, userID uint64) (pa1 []postgres.Position, err error)
	funcGetCartOrigin    string
	inspectFuncGetCart   func(ctx context.Context, userID uint64)
	afterGetCartCounter  uint64
	beforeGetCartCounter uint64
	GetCartMock          mRepositoryIfaceMockGetCart
}

// NewRepositoryIfaceMock returns a mock for mm_interfaces.RepositoryIface
func NewRepositoryIfaceMock(t minimock.Tester) *RepositoryIfaceMock {
	m := &RepositoryIfaceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mRepositoryIfaceMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*RepositoryIfaceMockAddItemParams{}

	m.ClearCartMock = mRepositoryIfaceMockClearCart{mock: m}
	m.ClearCartMock.callArgs = []*RepositoryIfaceMockClearCartParams{}

	m.DeleteItemMock = mRepositoryIfaceMockDeleteItem{mock: m}
	m.DeleteItemMock.callArgs = []*RepositoryIfaceMockDeleteItemParams{}

	m.GetCartMock = mRepositoryIfaceMockGetCart{mock: m}
	m.GetCartMock.callArgs = []*RepositoryIfaceMockGetCartParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryIfaceMockAddItem struct {
	optional           bool
	mock               *RepositoryIfaceMock
	defaultExpectation *RepositoryIfaceMockAddItemExpectation
	expectations       []*RepositoryIfaceMockAddItemExpectation

	callArgs []*RepositoryIfaceMockAddItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryIfaceMockAddItemExpectation specifies expectation struct of the RepositoryIface.AddItem
type RepositoryIfaceMockAddItemExpectation struct {
	mock               *RepositoryIfaceMock
	params             *RepositoryIfaceMockAddItemParams
	paramPtrs          *RepositoryIfaceMockAddItemParamPtrs
	expectationOrigins RepositoryIfaceMockAddItemExpectationOrigins
	results            *RepositoryIfaceMockAddItemResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryIfaceMockAddItemParams contains parameters of the RepositoryIface.AddItem
type RepositoryIfaceMockAddItemParams struct {
	ctx    context.Context
	userID uint64
	skuID  uint64
	count  uint64
}

// RepositoryIfaceMockAddItemParamPtrs contains pointers to parameters of the RepositoryIface.AddItem
type RepositoryIfaceMockAddItemParamPtrs struct {
	ctx    *context.Context
	userID *uint64
	skuID  *uint64
	count  *uint64
}

// RepositoryIfaceMockAddItemResults contains results of the RepositoryIface.AddItem
type RepositoryIfaceMockAddItemResults struct {
	err error
}

// RepositoryIfaceMockAddItemOrigins contains origins of expectations of the RepositoryIface.AddItem
type RepositoryIfaceMockAddItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originSkuID  string
	originCount  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItem *mRepositoryIfaceMockAddItem) Optional() *mRepositoryIfaceMockAddItem {
	mmAddItem.optional = true
	return mmAddItem
}

// Expect sets up expected params for RepositoryIface.AddItem
func (mmAddItem *mRepositoryIfaceMockAddItem) Expect(ctx context.Context, userID uint64, skuID uint64, count uint64) *mRepositoryIfaceMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryIfaceMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &RepositoryIfaceMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.paramPtrs != nil {
		mmAddItem.mock.t.Fatalf("RepositoryIfaceMock.AddItem mock is already set by ExpectParams functions")
	}

	mmAddItem.defaultExpectation.params = &RepositoryIfaceMockAddItemParams{ctx, userID, skuID, count}
	mmAddItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryIface.AddItem
func (mmAddItem *mRepositoryIfaceMockAddItem) ExpectCtxParam1(ctx context.Context) *mRepositoryIfaceMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryIfaceMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &RepositoryIfaceMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("RepositoryIfaceMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &RepositoryIfaceMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectUserIDParam2 sets up expected param userID for RepositoryIface.AddItem
func (mmAddItem *mRepositoryIfaceMockAddItem) ExpectUserIDParam2(userID uint64) *mRepositoryIfaceMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryIfaceMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &RepositoryIfaceMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("RepositoryIfaceMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &RepositoryIfaceMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.userID = &userID
	mmAddItem.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectSkuIDParam3 sets up expected param skuID for RepositoryIface.AddItem
func (mmAddItem *mRepositoryIfaceMockAddItem) ExpectSkuIDParam3(skuID uint64) *mRepositoryIfaceMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryIfaceMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &RepositoryIfaceMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("RepositoryIfaceMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &RepositoryIfaceMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.skuID = &skuID
	mmAddItem.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectCountParam4 sets up expected param count for RepositoryIface.AddItem
func (mmAddItem *mRepositoryIfaceMockAddItem) ExpectCountParam4(count uint64) *mRepositoryIfaceMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryIfaceMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &RepositoryIfaceMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("RepositoryIfaceMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &RepositoryIfaceMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.count = &count
	mmAddItem.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the RepositoryIface.AddItem
func (mmAddItem *mRepositoryIfaceMockAddItem) Inspect(f func(ctx context.Context, userID uint64, skuID uint64, count uint64)) *mRepositoryIfaceMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for RepositoryIfaceMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by RepositoryIface.AddItem
func (mmAddItem *mRepositoryIfaceMockAddItem) Return(err error) *RepositoryIfaceMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryIfaceMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &RepositoryIfaceMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &RepositoryIfaceMockAddItemResults{err}
	mmAddItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// Set uses given function f to mock the RepositoryIface.AddItem method
func (mmAddItem *mRepositoryIfaceMockAddItem) Set(f func(ctx context.Context, userID uint64, skuID uint64, count uint64) (err error)) *RepositoryIfaceMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the RepositoryIface.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the RepositoryIface.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	mmAddItem.mock.funcAddItemOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// When sets expectation for the RepositoryIface.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mRepositoryIfaceMockAddItem) When(ctx context.Context, userID uint64, skuID uint64, count uint64) *RepositoryIfaceMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryIfaceMock.AddItem mock is already set by Set")
	}

	expectation := &RepositoryIfaceMockAddItemExpectation{
		mock:               mmAddItem.mock,
		params:             &RepositoryIfaceMockAddItemParams{ctx, userID, skuID, count},
		expectationOrigins: RepositoryIfaceMockAddItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up RepositoryIface.AddItem return parameters for the expectation previously defined by the When method
func (e *RepositoryIfaceMockAddItemExpectation) Then(err error) *RepositoryIfaceMock {
	e.results = &RepositoryIfaceMockAddItemResults{err}
	return e.mock
}

// Times sets number of times RepositoryIface.AddItem should be invoked
func (mmAddItem *mRepositoryIfaceMockAddItem) Times(n uint64) *mRepositoryIfaceMockAddItem {
	if n == 0 {
		mmAddItem.mock.t.Fatalf("Times of RepositoryIfaceMock.AddItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItem.expectedInvocations, n)
	mmAddItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddItem
}

func (mmAddItem *mRepositoryIfaceMockAddItem) invocationsDone() bool {
	if len(mmAddItem.expectations) == 0 && mmAddItem.defaultExpectation == nil && mmAddItem.mock.funcAddItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItem.mock.afterAddItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItem implements mm_interfaces.RepositoryIface
func (mmAddItem *RepositoryIfaceMock) AddItem(ctx context.Context, userID uint64, skuID uint64, count uint64) (err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	mmAddItem.t.Helper()

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(ctx, userID, skuID, count)
	}

	mm_params := RepositoryIfaceMockAddItemParams{ctx, userID, skuID, count}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddItem.AddItemMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIfaceMockAddItemParams{ctx, userID, skuID, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddItem.t.Errorf("RepositoryIfaceMock.AddItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmAddItem.t.Errorf("RepositoryIfaceMock.AddItem got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmAddItem.t.Errorf("RepositoryIfaceMock.AddItem got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmAddItem.t.Errorf("RepositoryIfaceMock.AddItem got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("RepositoryIfaceMock.AddItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the RepositoryIfaceMock.AddItem")
		}
		return (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(ctx, userID, skuID, count)
	}
	mmAddItem.t.Fatalf("Unexpected call to RepositoryIfaceMock.AddItem. %v %v %v %v", ctx, userID, skuID, count)
	return
}

// AddItemAfterCounter returns a count of finished RepositoryIfaceMock.AddItem invocations
func (mmAddItem *RepositoryIfaceMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of RepositoryIfaceMock.AddItem invocations
func (mmAddItem *RepositoryIfaceMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIfaceMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mRepositoryIfaceMockAddItem) Calls() []*RepositoryIfaceMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*RepositoryIfaceMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *RepositoryIfaceMock) MinimockAddItemDone() bool {
	if m.AddItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemMock.invocationsDone()
}

// MinimockAddItemInspect logs each unmet expectation
func (m *RepositoryIfaceMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIfaceMock.AddItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddItemCounter := mm_atomic.LoadUint64(&m.afterAddItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && afterAddItemCounter < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryIfaceMock.AddItem at\n%s", m.AddItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryIfaceMock.AddItem at\n%s with params: %#v", m.AddItemMock.defaultExpectation.expectationOrigins.origin, *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && afterAddItemCounter < 1 {
		m.t.Errorf("Expected call to RepositoryIfaceMock.AddItem at\n%s", m.funcAddItemOrigin)
	}

	if !m.AddItemMock.invocationsDone() && afterAddItemCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIfaceMock.AddItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemMock.expectedInvocations), m.AddItemMock.expectedInvocationsOrigin, afterAddItemCounter)
	}
}

type mRepositoryIfaceMockClearCart struct {
	optional           bool
	mock               *RepositoryIfaceMock
	defaultExpectation *RepositoryIfaceMockClearCartExpectation
	expectations       []*RepositoryIfaceMockClearCartExpectation

	callArgs []*RepositoryIfaceMockClearCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryIfaceMockClearCartExpectation specifies expectation struct of the RepositoryIface.ClearCart
type RepositoryIfaceMockClearCartExpectation struct {
	mock               *RepositoryIfaceMock
	params             *RepositoryIfaceMockClearCartParams
	paramPtrs          *RepositoryIfaceMockClearCartParamPtrs
	expectationOrigins RepositoryIfaceMockClearCartExpectationOrigins
	results            *RepositoryIfaceMockClearCartResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryIfaceMockClearCartParams contains parameters of the RepositoryIface.ClearCart
type RepositoryIfaceMockClearCartParams struct {
	ctx    context.Context
	userID uint64
}

// RepositoryIfaceMockClearCartParamPtrs contains pointers to parameters of the RepositoryIface.ClearCart
type RepositoryIfaceMockClearCartParamPtrs struct {
	ctx    *context.Context
	userID *uint64
}

// RepositoryIfaceMockClearCartResults contains results of the RepositoryIface.ClearCart
type RepositoryIfaceMockClearCartResults struct {
	err error
}

// RepositoryIfaceMockClearCartOrigins contains origins of expectations of the RepositoryIface.ClearCart
type RepositoryIfaceMockClearCartExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClearCart *mRepositoryIfaceMockClearCart) Optional() *mRepositoryIfaceMockClearCart {
	mmClearCart.optional = true
	return mmClearCart
}

// Expect sets up expected params for RepositoryIface.ClearCart
func (mmClearCart *mRepositoryIfaceMockClearCart) Expect(ctx context.Context, userID uint64) *mRepositoryIfaceMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("RepositoryIfaceMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &RepositoryIfaceMockClearCartExpectation{}
	}

	if mmClearCart.defaultExpectation.paramPtrs != nil {
		mmClearCart.mock.t.Fatalf("RepositoryIfaceMock.ClearCart mock is already set by ExpectParams functions")
	}

	mmClearCart.defaultExpectation.params = &RepositoryIfaceMockClearCartParams{ctx, userID}
	mmClearCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmClearCart.expectations {
		if minimock.Equal(e.params, mmClearCart.defaultExpectation.params) {
			mmClearCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClearCart.defaultExpectation.params)
		}
	}

	return mmClearCart
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryIface.ClearCart
func (mmClearCart *mRepositoryIfaceMockClearCart) ExpectCtxParam1(ctx context.Context) *mRepositoryIfaceMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("RepositoryIfaceMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &RepositoryIfaceMockClearCartExpectation{}
	}

	if mmClearCart.defaultExpectation.params != nil {
		mmClearCart.mock.t.Fatalf("RepositoryIfaceMock.ClearCart mock is already set by Expect")
	}

	if mmClearCart.defaultExpectation.paramPtrs == nil {
		mmClearCart.defaultExpectation.paramPtrs = &RepositoryIfaceMockClearCartParamPtrs{}
	}
	mmClearCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmClearCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmClearCart
}

// ExpectUserIDParam2 sets up expected param userID for RepositoryIface.ClearCart
func (mmClearCart *mRepositoryIfaceMockClearCart) ExpectUserIDParam2(userID uint64) *mRepositoryIfaceMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("RepositoryIfaceMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &RepositoryIfaceMockClearCartExpectation{}
	}

	if mmClearCart.defaultExpectation.params != nil {
		mmClearCart.mock.t.Fatalf("RepositoryIfaceMock.ClearCart mock is already set by Expect")
	}

	if mmClearCart.defaultExpectation.paramPtrs == nil {
		mmClearCart.defaultExpectation.paramPtrs = &RepositoryIfaceMockClearCartParamPtrs{}
	}
	mmClearCart.defaultExpectation.paramPtrs.userID = &userID
	mmClearCart.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmClearCart
}

// Inspect accepts an inspector function that has same arguments as the RepositoryIface.ClearCart
func (mmClearCart *mRepositoryIfaceMockClearCart) Inspect(f func(ctx context.Context, userID uint64)) *mRepositoryIfaceMockClearCart {
	if mmClearCart.mock.inspectFuncClearCart != nil {
		mmClearCart.mock.t.Fatalf("Inspect function is already set for RepositoryIfaceMock.ClearCart")
	}

	mmClearCart.mock.inspectFuncClearCart = f

	return mmClearCart
}

// Return sets up results that will be returned by RepositoryIface.ClearCart
func (mmClearCart *mRepositoryIfaceMockClearCart) Return(err error) *RepositoryIfaceMock {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("RepositoryIfaceMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &RepositoryIfaceMockClearCartExpectation{mock: mmClearCart.mock}
	}
	mmClearCart.defaultExpectation.results = &RepositoryIfaceMockClearCartResults{err}
	mmClearCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClearCart.mock
}

// Set uses given function f to mock the RepositoryIface.ClearCart method
func (mmClearCart *mRepositoryIfaceMockClearCart) Set(f func(ctx context.Context, userID uint64) (err error)) *RepositoryIfaceMock {
	if mmClearCart.defaultExpectation != nil {
		mmClearCart.mock.t.Fatalf("Default expectation is already set for the RepositoryIface.ClearCart method")
	}

	if len(mmClearCart.expectations) > 0 {
		mmClearCart.mock.t.Fatalf("Some expectations are already set for the RepositoryIface.ClearCart method")
	}

	mmClearCart.mock.funcClearCart = f
	mmClearCart.mock.funcClearCartOrigin = minimock.CallerInfo(1)
	return mmClearCart.mock
}

// When sets expectation for the RepositoryIface.ClearCart which will trigger the result defined by the following
// Then helper
func (mmClearCart *mRepositoryIfaceMockClearCart) When(ctx context.Context, userID uint64) *RepositoryIfaceMockClearCartExpectation {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("RepositoryIfaceMock.ClearCart mock is already set by Set")
	}

	expectation := &RepositoryIfaceMockClearCartExpectation{
		mock:               mmClearCart.mock,
		params:             &RepositoryIfaceMockClearCartParams{ctx, userID},
		expectationOrigins: RepositoryIfaceMockClearCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmClearCart.expectations = append(mmClearCart.expectations, expectation)
	return expectation
}

// Then sets up RepositoryIface.ClearCart return parameters for the expectation previously defined by the When method
func (e *RepositoryIfaceMockClearCartExpectation) Then(err error) *RepositoryIfaceMock {
	e.results = &RepositoryIfaceMockClearCartResults{err}
	return e.mock
}

// Times sets number of times RepositoryIface.ClearCart should be invoked
func (mmClearCart *mRepositoryIfaceMockClearCart) Times(n uint64) *mRepositoryIfaceMockClearCart {
	if n == 0 {
		mmClearCart.mock.t.Fatalf("Times of RepositoryIfaceMock.ClearCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClearCart.expectedInvocations, n)
	mmClearCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClearCart
}

func (mmClearCart *mRepositoryIfaceMockClearCart) invocationsDone() bool {
	if len(mmClearCart.expectations) == 0 && mmClearCart.defaultExpectation == nil && mmClearCart.mock.funcClearCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClearCart.mock.afterClearCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClearCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ClearCart implements mm_interfaces.RepositoryIface
func (mmClearCart *RepositoryIfaceMock) ClearCart(ctx context.Context, userID uint64) (err error) {
	mm_atomic.AddUint64(&mmClearCart.beforeClearCartCounter, 1)
	defer mm_atomic.AddUint64(&mmClearCart.afterClearCartCounter, 1)

	mmClearCart.t.Helper()

	if mmClearCart.inspectFuncClearCart != nil {
		mmClearCart.inspectFuncClearCart(ctx, userID)
	}

	mm_params := RepositoryIfaceMockClearCartParams{ctx, userID}

	// Record call args
	mmClearCart.ClearCartMock.mutex.Lock()
	mmClearCart.ClearCartMock.callArgs = append(mmClearCart.ClearCartMock.callArgs, &mm_params)
	mmClearCart.ClearCartMock.mutex.Unlock()

	for _, e := range mmClearCart.ClearCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClearCart.ClearCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClearCart.ClearCartMock.defaultExpectation.Counter, 1)
		mm_want := mmClearCart.ClearCartMock.defaultExpectation.params
		mm_want_ptrs := mmClearCart.ClearCartMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIfaceMockClearCartParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmClearCart.t.Errorf("RepositoryIfaceMock.ClearCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClearCart.ClearCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmClearCart.t.Errorf("RepositoryIfaceMock.ClearCart got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClearCart.ClearCartMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClearCart.t.Errorf("RepositoryIfaceMock.ClearCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmClearCart.ClearCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClearCart.ClearCartMock.defaultExpectation.results
		if mm_results == nil {
			mmClearCart.t.Fatal("No results are set for the RepositoryIfaceMock.ClearCart")
		}
		return (*mm_results).err
	}
	if mmClearCart.funcClearCart != nil {
		return mmClearCart.funcClearCart(ctx, userID)
	}
	mmClearCart.t.Fatalf("Unexpected call to RepositoryIfaceMock.ClearCart. %v %v", ctx, userID)
	return
}

// ClearCartAfterCounter returns a count of finished RepositoryIfaceMock.ClearCart invocations
func (mmClearCart *RepositoryIfaceMock) ClearCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCart.afterClearCartCounter)
}

// ClearCartBeforeCounter returns a count of RepositoryIfaceMock.ClearCart invocations
func (mmClearCart *RepositoryIfaceMock) ClearCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCart.beforeClearCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIfaceMock.ClearCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClearCart *mRepositoryIfaceMockClearCart) Calls() []*RepositoryIfaceMockClearCartParams {
	mmClearCart.mutex.RLock()

	argCopy := make([]*RepositoryIfaceMockClearCartParams, len(mmClearCart.callArgs))
	copy(argCopy, mmClearCart.callArgs)

	mmClearCart.mutex.RUnlock()

	return argCopy
}

// MinimockClearCartDone returns true if the count of the ClearCart invocations corresponds
// the number of defined expectations
func (m *RepositoryIfaceMock) MinimockClearCartDone() bool {
	if m.ClearCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClearCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClearCartMock.invocationsDone()
}

// MinimockClearCartInspect logs each unmet expectation
func (m *RepositoryIfaceMock) MinimockClearCartInspect() {
	for _, e := range m.ClearCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIfaceMock.ClearCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterClearCartCounter := mm_atomic.LoadUint64(&m.afterClearCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClearCartMock.defaultExpectation != nil && afterClearCartCounter < 1 {
		if m.ClearCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryIfaceMock.ClearCart at\n%s", m.ClearCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryIfaceMock.ClearCart at\n%s with params: %#v", m.ClearCartMock.defaultExpectation.expectationOrigins.origin, *m.ClearCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClearCart != nil && afterClearCartCounter < 1 {
		m.t.Errorf("Expected call to RepositoryIfaceMock.ClearCart at\n%s", m.funcClearCartOrigin)
	}

	if !m.ClearCartMock.invocationsDone() && afterClearCartCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIfaceMock.ClearCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ClearCartMock.expectedInvocations), m.ClearCartMock.expectedInvocationsOrigin, afterClearCartCounter)
	}
}

type mRepositoryIfaceMockDeleteItem struct {
	optional           bool
	mock               *RepositoryIfaceMock
	defaultExpectation *RepositoryIfaceMockDeleteItemExpectation
	expectations       []*RepositoryIfaceMockDeleteItemExpectation

	callArgs []*RepositoryIfaceMockDeleteItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryIfaceMockDeleteItemExpectation specifies expectation struct of the RepositoryIface.DeleteItem
type RepositoryIfaceMockDeleteItemExpectation struct {
	mock               *RepositoryIfaceMock
	params             *RepositoryIfaceMockDeleteItemParams
	paramPtrs          *RepositoryIfaceMockDeleteItemParamPtrs
	expectationOrigins RepositoryIfaceMockDeleteItemExpectationOrigins
	results            *RepositoryIfaceMockDeleteItemResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryIfaceMockDeleteItemParams contains parameters of the RepositoryIface.DeleteItem
type RepositoryIfaceMockDeleteItemParams struct {
	ctx    context.Context
	userID uint64
	skuID  uint64
}

// RepositoryIfaceMockDeleteItemParamPtrs contains pointers to parameters of the RepositoryIface.DeleteItem
type RepositoryIfaceMockDeleteItemParamPtrs struct {
	ctx    *context.Context
	userID *uint64
	skuID  *uint64
}

// RepositoryIfaceMockDeleteItemResults contains results of the RepositoryIface.DeleteItem
type RepositoryIfaceMockDeleteItemResults struct {
	err error
}

// RepositoryIfaceMockDeleteItemOrigins contains origins of expectations of the RepositoryIface.DeleteItem
type RepositoryIfaceMockDeleteItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originSkuID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItem *mRepositoryIfaceMockDeleteItem) Optional() *mRepositoryIfaceMockDeleteItem {
	mmDeleteItem.optional = true
	return mmDeleteItem
}

// Expect sets up expected params for RepositoryIface.DeleteItem
func (mmDeleteItem *mRepositoryIfaceMockDeleteItem) Expect(ctx context.Context, userID uint64, skuID uint64) *mRepositoryIfaceMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryIfaceMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &RepositoryIfaceMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.paramPtrs != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryIfaceMock.DeleteItem mock is already set by ExpectParams functions")
	}

	mmDeleteItem.defaultExpectation.params = &RepositoryIfaceMockDeleteItemParams{ctx, userID, skuID}
	mmDeleteItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteItem.expectations {
		if minimock.Equal(e.params, mmDeleteItem.defaultExpectation.params) {
			mmDeleteItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItem.defaultExpectation.params)
		}
	}

	return mmDeleteItem
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryIface.DeleteItem
func (mmDeleteItem *mRepositoryIfaceMockDeleteItem) ExpectCtxParam1(ctx context.Context) *mRepositoryIfaceMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryIfaceMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &RepositoryIfaceMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryIfaceMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &RepositoryIfaceMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectUserIDParam2 sets up expected param userID for RepositoryIface.DeleteItem
func (mmDeleteItem *mRepositoryIfaceMockDeleteItem) ExpectUserIDParam2(userID uint64) *mRepositoryIfaceMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryIfaceMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &RepositoryIfaceMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryIfaceMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &RepositoryIfaceMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteItem.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectSkuIDParam3 sets up expected param skuID for RepositoryIface.DeleteItem
func (mmDeleteItem *mRepositoryIfaceMockDeleteItem) ExpectSkuIDParam3(skuID uint64) *mRepositoryIfaceMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryIfaceMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &RepositoryIfaceMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryIfaceMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &RepositoryIfaceMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.skuID = &skuID
	mmDeleteItem.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmDeleteItem
}

// Inspect accepts an inspector function that has same arguments as the RepositoryIface.DeleteItem
func (mmDeleteItem *mRepositoryIfaceMockDeleteItem) Inspect(f func(ctx context.Context, userID uint64, skuID uint64)) *mRepositoryIfaceMockDeleteItem {
	if mmDeleteItem.mock.inspectFuncDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("Inspect function is already set for RepositoryIfaceMock.DeleteItem")
	}

	mmDeleteItem.mock.inspectFuncDeleteItem = f

	return mmDeleteItem
}

// Return sets up results that will be returned by RepositoryIface.DeleteItem
func (mmDeleteItem *mRepositoryIfaceMockDeleteItem) Return(err error) *RepositoryIfaceMock {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryIfaceMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &RepositoryIfaceMockDeleteItemExpectation{mock: mmDeleteItem.mock}
	}
	mmDeleteItem.defaultExpectation.results = &RepositoryIfaceMockDeleteItemResults{err}
	mmDeleteItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// Set uses given function f to mock the RepositoryIface.DeleteItem method
func (mmDeleteItem *mRepositoryIfaceMockDeleteItem) Set(f func(ctx context.Context, userID uint64, skuID uint64) (err error)) *RepositoryIfaceMock {
	if mmDeleteItem.defaultExpectation != nil {
		mmDeleteItem.mock.t.Fatalf("Default expectation is already set for the RepositoryIface.DeleteItem method")
	}

	if len(mmDeleteItem.expectations) > 0 {
		mmDeleteItem.mock.t.Fatalf("Some expectations are already set for the RepositoryIface.DeleteItem method")
	}

	mmDeleteItem.mock.funcDeleteItem = f
	mmDeleteItem.mock.funcDeleteItemOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// When sets expectation for the RepositoryIface.DeleteItem which will trigger the result defined by the following
// Then helper
func (mmDeleteItem *mRepositoryIfaceMockDeleteItem) When(ctx context.Context, userID uint64, skuID uint64) *RepositoryIfaceMockDeleteItemExpectation {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryIfaceMock.DeleteItem mock is already set by Set")
	}

	expectation := &RepositoryIfaceMockDeleteItemExpectation{
		mock:               mmDeleteItem.mock,
		params:             &RepositoryIfaceMockDeleteItemParams{ctx, userID, skuID},
		expectationOrigins: RepositoryIfaceMockDeleteItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteItem.expectations = append(mmDeleteItem.expectations, expectation)
	return expectation
}

// Then sets up RepositoryIface.DeleteItem return parameters for the expectation previously defined by the When method
func (e *RepositoryIfaceMockDeleteItemExpectation) Then(err error) *RepositoryIfaceMock {
	e.results = &RepositoryIfaceMockDeleteItemResults{err}
	return e.mock
}

// Times sets number of times RepositoryIface.DeleteItem should be invoked
func (mmDeleteItem *mRepositoryIfaceMockDeleteItem) Times(n uint64) *mRepositoryIfaceMockDeleteItem {
	if n == 0 {
		mmDeleteItem.mock.t.Fatalf("Times of RepositoryIfaceMock.DeleteItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItem.expectedInvocations, n)
	mmDeleteItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteItem
}

func (mmDeleteItem *mRepositoryIfaceMockDeleteItem) invocationsDone() bool {
	if len(mmDeleteItem.expectations) == 0 && mmDeleteItem.defaultExpectation == nil && mmDeleteItem.mock.funcDeleteItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItem.mock.afterDeleteItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItem implements mm_interfaces.RepositoryIface
func (mmDeleteItem *RepositoryIfaceMock) DeleteItem(ctx context.Context, userID uint64, skuID uint64) (err error) {
	mm_atomic.AddUint64(&mmDeleteItem.beforeDeleteItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItem.afterDeleteItemCounter, 1)

	mmDeleteItem.t.Helper()

	if mmDeleteItem.inspectFuncDeleteItem != nil {
		mmDeleteItem.inspectFuncDeleteItem(ctx, userID, skuID)
	}

	mm_params := RepositoryIfaceMockDeleteItemParams{ctx, userID, skuID}

	// Record call args
	mmDeleteItem.DeleteItemMock.mutex.Lock()
	mmDeleteItem.DeleteItemMock.callArgs = append(mmDeleteItem.DeleteItemMock.callArgs, &mm_params)
	mmDeleteItem.DeleteItemMock.mutex.Unlock()

	for _, e := range mmDeleteItem.DeleteItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItem.DeleteItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItem.DeleteItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItem.DeleteItemMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItem.DeleteItemMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIfaceMockDeleteItemParams{ctx, userID, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItem.t.Errorf("RepositoryIfaceMock.DeleteItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteItem.t.Errorf("RepositoryIfaceMock.DeleteItem got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmDeleteItem.t.Errorf("RepositoryIfaceMock.DeleteItem got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItem.t.Errorf("RepositoryIfaceMock.DeleteItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItem.DeleteItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItem.t.Fatal("No results are set for the RepositoryIfaceMock.DeleteItem")
		}
		return (*mm_results).err
	}
	if mmDeleteItem.funcDeleteItem != nil {
		return mmDeleteItem.funcDeleteItem(ctx, userID, skuID)
	}
	mmDeleteItem.t.Fatalf("Unexpected call to RepositoryIfaceMock.DeleteItem. %v %v %v", ctx, userID, skuID)
	return
}

// DeleteItemAfterCounter returns a count of finished RepositoryIfaceMock.DeleteItem invocations
func (mmDeleteItem *RepositoryIfaceMock) DeleteItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.afterDeleteItemCounter)
}

// DeleteItemBeforeCounter returns a count of RepositoryIfaceMock.DeleteItem invocations
func (mmDeleteItem *RepositoryIfaceMock) DeleteItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.beforeDeleteItemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIfaceMock.DeleteItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItem *mRepositoryIfaceMockDeleteItem) Calls() []*RepositoryIfaceMockDeleteItemParams {
	mmDeleteItem.mutex.RLock()

	argCopy := make([]*RepositoryIfaceMockDeleteItemParams, len(mmDeleteItem.callArgs))
	copy(argCopy, mmDeleteItem.callArgs)

	mmDeleteItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemDone returns true if the count of the DeleteItem invocations corresponds
// the number of defined expectations
func (m *RepositoryIfaceMock) MinimockDeleteItemDone() bool {
	if m.DeleteItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemMock.invocationsDone()
}

// MinimockDeleteItemInspect logs each unmet expectation
func (m *RepositoryIfaceMock) MinimockDeleteItemInspect() {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIfaceMock.DeleteItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteItemCounter := mm_atomic.LoadUint64(&m.afterDeleteItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && afterDeleteItemCounter < 1 {
		if m.DeleteItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryIfaceMock.DeleteItem at\n%s", m.DeleteItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryIfaceMock.DeleteItem at\n%s with params: %#v", m.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *m.DeleteItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && afterDeleteItemCounter < 1 {
		m.t.Errorf("Expected call to RepositoryIfaceMock.DeleteItem at\n%s", m.funcDeleteItemOrigin)
	}

	if !m.DeleteItemMock.invocationsDone() && afterDeleteItemCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIfaceMock.DeleteItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemMock.expectedInvocations), m.DeleteItemMock.expectedInvocationsOrigin, afterDeleteItemCounter)
	}
}

type mRepositoryIfaceMockGetCart struct {
	optional           bool
	mock               *RepositoryIfaceMock
	defaultExpectation *RepositoryIfaceMockGetCartExpectation
	expectations       []*RepositoryIfaceMockGetCartExpectation

	callArgs []*RepositoryIfaceMockGetCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryIfaceMockGetCartExpectation specifies expectation struct of the RepositoryIface.GetCart
type RepositoryIfaceMockGetCartExpectation struct {
	mock               *RepositoryIfaceMock
	params             *RepositoryIfaceMockGetCartParams
	paramPtrs          *RepositoryIfaceMockGetCartParamPtrs
	expectationOrigins RepositoryIfaceMockGetCartExpectationOrigins
	results            *RepositoryIfaceMockGetCartResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryIfaceMockGetCartParams contains parameters of the RepositoryIface.GetCart
type RepositoryIfaceMockGetCartParams struct {
	ctx    context.Context
	userID uint64
}

// RepositoryIfaceMockGetCartParamPtrs contains pointers to parameters of the RepositoryIface.GetCart
type RepositoryIfaceMockGetCartParamPtrs struct {
	ctx    *context.Context
	userID *uint64
}

// RepositoryIfaceMockGetCartResults contains results of the RepositoryIface.GetCart
type RepositoryIfaceMockGetCartResults struct {
	pa1 []postgres.Position
	err error
}

// RepositoryIfaceMockGetCartOrigins contains origins of expectations of the RepositoryIface.GetCart
type RepositoryIfaceMockGetCartExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCart *mRepositoryIfaceMockGetCart) Optional() *mRepositoryIfaceMockGetCart {
	mmGetCart.optional = true
	return mmGetCart
}

// Expect sets up expected params for RepositoryIface.GetCart
func (mmGetCart *mRepositoryIfaceMockGetCart) Expect(ctx context.Context, userID uint64) *mRepositoryIfaceMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("RepositoryIfaceMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &RepositoryIfaceMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.paramPtrs != nil {
		mmGetCart.mock.t.Fatalf("RepositoryIfaceMock.GetCart mock is already set by ExpectParams functions")
	}

	mmGetCart.defaultExpectation.params = &RepositoryIfaceMockGetCartParams{ctx, userID}
	mmGetCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCart.expectations {
		if minimock.Equal(e.params, mmGetCart.defaultExpectation.params) {
			mmGetCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCart.defaultExpectation.params)
		}
	}

	return mmGetCart
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryIface.GetCart
func (mmGetCart *mRepositoryIfaceMockGetCart) ExpectCtxParam1(ctx context.Context) *mRepositoryIfaceMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("RepositoryIfaceMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &RepositoryIfaceMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("RepositoryIfaceMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &RepositoryIfaceMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCart
}

// ExpectUserIDParam2 sets up expected param userID for RepositoryIface.GetCart
func (mmGetCart *mRepositoryIfaceMockGetCart) ExpectUserIDParam2(userID uint64) *mRepositoryIfaceMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("RepositoryIfaceMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &RepositoryIfaceMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("RepositoryIfaceMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &RepositoryIfaceMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.userID = &userID
	mmGetCart.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetCart
}

// Inspect accepts an inspector function that has same arguments as the RepositoryIface.GetCart
func (mmGetCart *mRepositoryIfaceMockGetCart) Inspect(f func(ctx context.Context, userID uint64)) *mRepositoryIfaceMockGetCart {
	if mmGetCart.mock.inspectFuncGetCart != nil {
		mmGetCart.mock.t.Fatalf("Inspect function is already set for RepositoryIfaceMock.GetCart")
	}

	mmGetCart.mock.inspectFuncGetCart = f

	return mmGetCart
}

// Return sets up results that will be returned by RepositoryIface.GetCart
func (mmGetCart *mRepositoryIfaceMockGetCart) Return(pa1 []postgres.Position, err error) *RepositoryIfaceMock {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("RepositoryIfaceMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &RepositoryIfaceMockGetCartExpectation{mock: mmGetCart.mock}
	}
	mmGetCart.defaultExpectation.results = &RepositoryIfaceMockGetCartResults{pa1, err}
	mmGetCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// Set uses given function f to mock the RepositoryIface.GetCart method
func (mmGetCart *mRepositoryIfaceMockGetCart) Set(f func(ctx context.Context, userID uint64) (pa1 []postgres.Position, err error)) *RepositoryIfaceMock {
	if mmGetCart.defaultExpectation != nil {
		mmGetCart.mock.t.Fatalf("Default expectation is already set for the RepositoryIface.GetCart method")
	}

	if len(mmGetCart.expectations) > 0 {
		mmGetCart.mock.t.Fatalf("Some expectations are already set for the RepositoryIface.GetCart method")
	}

	mmGetCart.mock.funcGetCart = f
	mmGetCart.mock.funcGetCartOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// When sets expectation for the RepositoryIface.GetCart which will trigger the result defined by the following
// Then helper
func (mmGetCart *mRepositoryIfaceMockGetCart) When(ctx context.Context, userID uint64) *RepositoryIfaceMockGetCartExpectation {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("RepositoryIfaceMock.GetCart mock is already set by Set")
	}

	expectation := &RepositoryIfaceMockGetCartExpectation{
		mock:               mmGetCart.mock,
		params:             &RepositoryIfaceMockGetCartParams{ctx, userID},
		expectationOrigins: RepositoryIfaceMockGetCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCart.expectations = append(mmGetCart.expectations, expectation)
	return expectation
}

// Then sets up RepositoryIface.GetCart return parameters for the expectation previously defined by the When method
func (e *RepositoryIfaceMockGetCartExpectation) Then(pa1 []postgres.Position, err error) *RepositoryIfaceMock {
	e.results = &RepositoryIfaceMockGetCartResults{pa1, err}
	return e.mock
}

// Times sets number of times RepositoryIface.GetCart should be invoked
func (mmGetCart *mRepositoryIfaceMockGetCart) Times(n uint64) *mRepositoryIfaceMockGetCart {
	if n == 0 {
		mmGetCart.mock.t.Fatalf("Times of RepositoryIfaceMock.GetCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCart.expectedInvocations, n)
	mmGetCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCart
}

func (mmGetCart *mRepositoryIfaceMockGetCart) invocationsDone() bool {
	if len(mmGetCart.expectations) == 0 && mmGetCart.defaultExpectation == nil && mmGetCart.mock.funcGetCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCart.mock.afterGetCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCart implements mm_interfaces.RepositoryIface
func (mmGetCart *RepositoryIfaceMock) GetCart(ctx context.Context, userID uint64) (pa1 []postgres.Position, err error) {
	mm_atomic.AddUint64(&mmGetCart.beforeGetCartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCart.afterGetCartCounter, 1)

	mmGetCart.t.Helper()

	if mmGetCart.inspectFuncGetCart != nil {
		mmGetCart.inspectFuncGetCart(ctx, userID)
	}

	mm_params := RepositoryIfaceMockGetCartParams{ctx, userID}

	// Record call args
	mmGetCart.GetCartMock.mutex.Lock()
	mmGetCart.GetCartMock.callArgs = append(mmGetCart.GetCartMock.callArgs, &mm_params)
	mmGetCart.GetCartMock.mutex.Unlock()

	for _, e := range mmGetCart.GetCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmGetCart.GetCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCart.GetCartMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCart.GetCartMock.defaultExpectation.params
		mm_want_ptrs := mmGetCart.GetCartMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIfaceMockGetCartParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCart.t.Errorf("RepositoryIfaceMock.GetCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetCart.t.Errorf("RepositoryIfaceMock.GetCart got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCart.t.Errorf("RepositoryIfaceMock.GetCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCart.GetCartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCart.t.Fatal("No results are set for the RepositoryIfaceMock.GetCart")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetCart.funcGetCart != nil {
		return mmGetCart.funcGetCart(ctx, userID)
	}
	mmGetCart.t.Fatalf("Unexpected call to RepositoryIfaceMock.GetCart. %v %v", ctx, userID)
	return
}

// GetCartAfterCounter returns a count of finished RepositoryIfaceMock.GetCart invocations
func (mmGetCart *RepositoryIfaceMock) GetCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.afterGetCartCounter)
}

// GetCartBeforeCounter returns a count of RepositoryIfaceMock.GetCart invocations
func (mmGetCart *RepositoryIfaceMock) GetCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.beforeGetCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIfaceMock.GetCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCart *mRepositoryIfaceMockGetCart) Calls() []*RepositoryIfaceMockGetCartParams {
	mmGetCart.mutex.RLock()

	argCopy := make([]*RepositoryIfaceMockGetCartParams, len(mmGetCart.callArgs))
	copy(argCopy, mmGetCart.callArgs)

	mmGetCart.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartDone returns true if the count of the GetCart invocations corresponds
// the number of defined expectations
func (m *RepositoryIfaceMock) MinimockGetCartDone() bool {
	if m.GetCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartMock.invocationsDone()
}

// MinimockGetCartInspect logs each unmet expectation
func (m *RepositoryIfaceMock) MinimockGetCartInspect() {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIfaceMock.GetCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCartCounter := mm_atomic.LoadUint64(&m.afterGetCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && afterGetCartCounter < 1 {
		if m.GetCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryIfaceMock.GetCart at\n%s", m.GetCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryIfaceMock.GetCart at\n%s with params: %#v", m.GetCartMock.defaultExpectation.expectationOrigins.origin, *m.GetCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && afterGetCartCounter < 1 {
		m.t.Errorf("Expected call to RepositoryIfaceMock.GetCart at\n%s", m.funcGetCartOrigin)
	}

	if !m.GetCartMock.invocationsDone() && afterGetCartCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIfaceMock.GetCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartMock.expectedInvocations), m.GetCartMock.expectedInvocationsOrigin, afterGetCartCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryIfaceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockClearCartInspect()

			m.MinimockDeleteItemInspect()

			m.MinimockGetCartInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryIfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryIfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockClearCartDone() &&
		m.MinimockDeleteItemDone() &&
		m.MinimockGetCartDone()
}
